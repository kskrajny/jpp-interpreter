Int i = 0 | 1 | (-1) | 2 | (-2) | ...

Bool b = True | False

String s = "<ciąg liter i cyfr>"

Val v = Int i | String s | Bool b 

Var x = <ciąg liter i cyfr>

Exp e = C v | V x | Add e1 e2 | Mul e1 e2 | Sub e1 e2 | Div e1 e2 |
    Equal e1 e2 | Less e1 e2 | And e1 e2 | Or e1 e2 | Not e

Decl d = DeclVar x d | DeclFunc x1 x2 x3 S d | EmptyDecl

Stmt S = x := e | SeqStmt S1 S2 | IfStmt e S | IfElseStmt e S1 S2 |
    WhileStmt b S | SkipStmt | BlockStmt d S | FuncStmt x e | PrintStmt e


exec :: Stmt -> IO()
    - uruchamia dany w argumencie Stmt
    - wypisuje te wyrażenia, które były argumentem PrintStmt w trakcie działaia programu 


Większość konstrukcji zachowują się tradycyjnie i o nich nie wspominam.

PrintStmt nie wypisuje, a zapisuje to, co ma być wypisane na koniec programu.

x2, x3 w deklaracji funkcji (DeclFunc) są odpowiednio argumentami in / out,
tzn, po zakończeniu funkcji wynik wykonania funkcji jest zapisywany do x3.

Widoczność identyfikatorów jest statyczna.

Zadeklarowane funkcje są zinterpretowane w środowisku gdzie:
- zmienna "return" jest deklarowana niejawnie przy pomocy newloc,
    wartość pod nowym adresem to undefined
- identyfikator x2 jest deklarowany niejawnie przy pomocy newloc,
    wartość pod nowym adresem jest ustalana w momencie wywołania funkcji
- widoczna jest ta funkcja, zatem możliwa jest rekurencja 

Wynik funkcji jest zapisywany w następujący sposób "return" := e.

Wywołanie funkcji zmienia tylko wartość pod adresem (Loc) wskazywanym przez
identyfikatore x3 z deklaracji.

Wymagamy, aby x3 istaniło.

x2 jest przekazywane przez wartość, a x3 przez referencje.