Int i = 0 | 1 | (-1) | 2 | (-2) | ...

Bool b = true | false

String s = "<ciąg liter i cyfr>"

Val v = i | s | b 

Var x = <ciąg liter i cyfr>

Exp e = v | x | e1 + e2 | e1 * e2 | e1 - e2 | e1 / e2 |
    e1 == e2 | e1 < e2 | e1 and e2 | e1 or e2 | not e

Decl d = var x d | func x1 x2 x3 S d | end declare

Stmt S = x := e |  S1; S2 | if e then S | if e then S1 else S2 |
    while b do S | skip | declare d S | run x e | print e


exec :: Stmt -> IO()
    - uruchamia dany w argumencie Stmt
    - wypisuje te wyrażenia, które były argumentem PrintStmt w trakcie działaia programu 


Większość konstrukcji zachowują się tradycyjnie i o nich nie wspominam.

PrintStmt nie wypisuje, a zapisuje to, co ma być wypisane na koniec programu.

x2, x3 w deklaracji funkcji (DeclFunc) są odpowiednio argumentami in / out,
tzn, po zakończeniu funkcji wynik wykonania funkcji jest zapisywany do x3.

Widoczność identyfikatorów jest statyczna.

Zadeklarowane funkcje są zinterpretowane w środowisku gdzie:
- zmienna "return" jest deklarowana niejawnie przy pomocy newloc,
    wartość pod nowym adresem to undefined
- identyfikator x2 jest deklarowany niejawnie przy pomocy newloc,
    wartość pod nowym adresem jest ustalana w momencie wywołania funkcji
- widoczna jest ta funkcja, zatem możliwa jest rekurencja 

Wynik funkcji jest zapisywany w następujący sposób "return" := e.

Wywołanie funkcji zmienia tylko wartość pod adresem (Loc) wskazywanym przez
identyfikatore x3 z deklaracji.

Wymagamy, aby x3 istaniło.

x2 jest przekazywane przez wartość, a x3 przez referencje.